/// Provides the [scan] operation on all [Iterable].
extension ScanExt<T> on Iterable<T> {
  /// Returns an [Iterable] containing successive accumulation values generated by applying [operation] from left to right
  /// to each element and current accumulator value that starts with [initial] value.
  ///
  /// The first element of the resulting iterable will be the [initial] value.
  /// The second element will be the result of applying [operation] to [initial].
  ///
  /// Therefore the [Iterable.length] of the resulting iterable will be one more than the length of the source iterable.
  Iterable<R> scan<R>(R initial, R Function(R, T) operation) {
    return [initial].followedBy(_ScanIterable<T, R>(this, initial, operation));
  }
}

/// An [Iterable] that implements the [scan] operation.
class _ScanIterable<T, R> extends Iterable<R> {
  const _ScanIterable(this._source, this.initial, this.operation);

  final Iterable<T> _source;
  final R initial;
  final R Function(R, T) operation;

  @override
  Iterator<R> get iterator => _ScanIterator<T, R>(_source.iterator, initial, operation);

  @override
  int get length => _source.length;

  @override
  bool get isEmpty => _source.isEmpty;

  @override
  bool get isNotEmpty => _source.isNotEmpty;

  @override
  R get first => operation(initial, _source.first);

  @override
  R get last => operation(initial, _source.last);

  @override
  R get single => operation(initial, _source.single);
}

/// An [Iterator] that implements the [scan] operation.
class _ScanIterator<T, R> implements Iterator<R> {
  _ScanIterator(this._source, R initial, this.operation) : current = initial;

  final Iterator<T> _source;
  final R Function(R, T) operation;

  @override
  R current;

  @override
  bool moveNext() {
    if (!_source.moveNext()) return false;

    current = operation(current, _source.current);
    return true;
  }
}
